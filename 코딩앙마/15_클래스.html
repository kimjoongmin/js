<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>클래스</title>
</head>
<body>
  <pre>

    생성자 함수와 class의 차이

    01. 클래스 생성자는 new와 함께 호출하지 않으면 에러가 발생한다.
    // class 생성
    class ClassName{
      constructor(){}
    }
    // 생성자 함수 생성
    function ConsName(){}
    // 호출
    ClassName(); // VM20:1 Uncaught TypeError: Class constructor ClassName cannot be invoked without 'new' at < anonymous >:1:1
    ConsName();

    02. 클래스 메서드는 열거할 수 없다.
    클래스의 prototype 프로퍼티에 추가된 메서드 전체의 enumerable 플래그는 false이다.
    - enumerable플래그는 for...in으로 객체 순환을 할 때, key의 값의 반환 유무를 뜻한다.
    - for...in으로 객체 순환을 할 때, prototype 프로퍼티에 저장된 함수 값을 반환하는 것에서 차이가 발생한다.
    생성자 함수 => 함수 반환O
    class => 함수 반환 X


    
    생성자 함수
    
    Class 함수

    상속 extends 

    메소드 오버라이딩

    생성자 오버라이딩

    


  </pre>

  <script>
    
    //생성자함수를 class로
    //예제
    function Student(name, age, height) {
      this.name = name;
      this.age = age;
      this.height = height;
    }
    Student.prototype.sayHi = function () {
      console.log(`내 이름은 ${this.name} 이고, 나이는 ${this.age}살 입니다. 키는 ${this.height}cm 입니다.`)
    }
    const Jane = new Student("Jane", "33", "170");
    Jane.sayHi();

    //바꾸기
    class Student2 {
      constructor(name, age, height) {
        this.name = name;
        this.age = age;
        this.height = height;
      }
      sayHi() {
        console.log(`내 이름은 ${this.name} 이고, 나이는 ${this.age}살 입니다. 키는 ${this.height}cm 입니다.`)
      }
    }
    const anna = new Student2("anna", "22", "160");
    anna.sayHi();



    //함수 선언식
    function User(name, age){
      this.name = name;
      this.age = age;
      // this.showName = function(){
      //   console.log(this.name);
      // }
    }
    User.prototype.showName = function(){
      console.log(this.name);
    }
    const mike = new User("Mike","33");

    //함수 표현식
    // const User = function(name, age){
    //   this.name = name;
    //   this.age = age;
    //   // this.showName = function(){ //class와 똑같이 만들려면 prototype
    //   //   console.log(this.name);
    //   // }
    // }
    // User.prototype.showName = function(){//class와 똑같이 만들려면 prototype
    //   console.log(this.name);
    // }
    // const mike = new User("Mike","33");

    class User2 {
      constructor(name, age){
        this.name = name;
        this.age = age;
      }
      showName(){
        console.log(this.name);
      }
    }
    const tom = new User2("Tom","10");


    // //생성자 함수
    // const User = function(name, age){
    //   this.name = name;
    //   this.age = age;
    //   this.showName = function(){
    //     console.log(this.name);
    //   }
    // }
    // const mike = new User('Mike',33);

    // //Class 함수 es6에 추가
    // class User2 {
    //   constructor(name, age){//객체를 만들어 주는 생성자 메소드
    //     this.name = name;
    //     this.age = age;
    //   }
    //   showName(){
    //     console.log(this.name);
    //   }
    // }
    // const tom = new User2("Tom","22");

    class Car {
      constructor(color){
        this.color = color;
        this.wheels = 4;
      }
      drive(){
        console.log("drive..")
      }
      stop(){
        console.log("stop!")
      }
    }
    class Bmw extends Car{
      constructor(color){ //생성자 오버라이딩 부모꺼 가져와야함
        super(color);//생성자 오버라이딩 부모꺼 가져와야함
        this.navigation = 1; //추가
      }
      stop(){//부모에도 있는 메소드 
        super.stop() //부모꺼도 호출하려면 super
        console.log("off")
      }
    }
    const x5 = new Bmw("black")


    //car class 만들어보기
    // class Car {
    //   constructor(color){
    //     this.color = color;
    //     this.wheels = 4;
    //   }
    //   drive(){
    //     console.log('drive..')
    //   }
    //   stop(){
    //     console.log('stop!')
    //   }
    // }

    // //extends
    // class Bmw extends Car{
    //   //생성자 오버라이딩
    //   //무조건 부모꺼 가져와야함
    //   // extends에서도 constructor가 아래처럼 항상 있는거
    //   // constructor(...args){
    //   //   super(...args);
    //   // }
    //   //생성자 오버라이딩을 하려면
    //   constructor(color){//부모꺼 그대로 가져오고
    //     super(color);//부모꺼 그대로 가져오고
    //     this.navigation = 1; //추가할 것을 추가
    //   }
    //   park(){
    //     console.log("park..");
    //   }
    //   //메소드 오버라이딩 car에도 stop이 있고 bmw에도 stop 이 있음
    //   stop(){
    //     //부모에서 사용하는 기능을 그대로 가져오려면
    //     super.stop();
    //     console.log('off..');
    //   }
    // }
    // const z4 = new Bmw('white');

  </script>
</body>
</html>