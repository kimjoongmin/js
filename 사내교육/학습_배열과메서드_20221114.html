<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>배열과 메서드</title>
</head>
<body>
  <pre>
    ***배열과 메서드
    배열은 다양한 메서드를 제공합니다



    ***요소 추가 제거 메서드 
    arr.push() 맨끝에 추가
    arr.pop() 맨끝에 제거
    arr.shift(); 맨 처음 제거
    arr.unshift(); 맨 처음 추가
    이 외에 요소 추가와 제거에 관련된 메서드를 알아봅시다


    ***splice
    배열에서 요소를 하나만 지우고 싶다면?
    배열 역시 객체형에 속하므로 프로퍼티를 지울때 쓰는 연산자 delete를 사용해볼수 있을겁니다
    let arr =['I','go','home'];
    delete arr[1]; //go를 삭제합니다
    alert(arr[1]); //undefined
    //delete를 써서 요소를 지우고 난 후 배열 -->arr = ['I', ,'home'];
    alert(arr.length); //3
    원하는대로 요소를 지웠지만 배열의요소는 여전히 세개이네요
    이는 자연스러운 결과입니다
    delete는 obj.key는 key를 이용해 해당키를 상응하는 값을 지우기 때문이죠
    delete 메서드는 제역할을 다한것입니다
    그런데 우리는 삭제된 요소가 만든 빈공간을 나머지 요소들이 자동으로 채울 것이라 기대하며 이메서드를 썼습니다
    배열의 길이가 더 짧아지길 기대하며 말이죠
    이런기대를 충족하려면 특별한 메서드를 사용해야합니다
    arr.splice(start)는 만능 스위스 맥가이버 칼 같은 메서드 입니다
    요소를 자유자재로 다룰 수 있게 해주죠
    이메서드를 사용하면 요소 추가,삭제,교체가 모두 가능합니다
    문법은 다음과 같습니다
    arr.splice(index,[deleteCount, elem1, elemN])
    첫번째 매개변수는 조작을 가할 첫번째 요소를 가리키는index입니다
    두번째 매개변수는 deleteCount로 제거하고자하는 요소의 개수를 나타냅니다
    elem1,...,elemN은 배열에 추가할 요소를 나타냅니다
    let arr = ['I','study','JavaScript'];
    arr.splice(1,1); 
    console.log(arr);// ['I','Javascript']
    쉽죠? 인덱스1이 가리키는 요소부터 시작해 요소 한개(1)를 지웠습니다
    다음 예시에선 요소 세 개(3)를 지우고 그자리에 다른 요소 두개로 교체해 보도록하겠습니다
    let arr1 = ['I','study','JavaScript','right','now'];
    arr1.splice(0,3,"Let's","dance");
    console.log(arr1); // ["Let's","dance","right","now"]
    splice 는 삭제된 요소로 구성된 배열을 반환합니다
    let arr = ['I','study','JavaScript','right','now'];
    let removed = arr.splice(0,2);
    alert(removed); "I","study" //삭제된 요소로 구성된 배열
    splice 메서드의deleteCount를 0으로 설정하면 요소를 제거하지 않으면서 새로운 요소를 추가할 수 있습니다
    let arr = ["I","study","JavaScript"];
    //인덱스 2부터
    //0개의 요소를 삭제합니다
    //그 후 "complex"와 "language" 를 추가합니다
    arr.splice(2,0,"complex","language");
    alert(arr); // "I","study","complex","language","JavaScript"
    음수 인덱스도 사용
    let arr = [1,2,5];
    arr.splice(-1,0,3,4);
    console.log(arr); //1,2,3,4,5


    ***slice 
    arr.slice 는 arr.splice와 유사해 보이지만 훨씬 간단합니다
    arr.slice([start],[end])
    이 메서드는 start 인덱스부터 (end를 제외한) end인덱스까지의 요소를 복사한 새로운 배열을 반환합니다
    start와 end는 둘다 음수일수 있는데 이땐 배열 끝에서부터의 요소 개수를 의미합니다
    arr.slice는 문자열 메서드인 str.slice 와 유사하게 동작하는데
    arr.slice는 서브 문자열대신 서브 배열을 반환한다는 점이 다릅니다
    let arr =["t","e","s","t"];
    alert(arr.slice(1,3)); / e,s 인덱스가 1인 요소부터 인덱스가 3인 요소까지를 복사 (인덱스가 3인요소는 제외)
    alert(arr.slice(-2)); //s,t 인덱스가 -2인 요소부터 제일 끝 요소까지를 복사 


    ***concat
    ***forEach로 반복작업하기
    arr.forEach는 주어진 함수를 배열 요소 각각에 대해 실행할수 있게 해줍니다
    arr.forEach(function(item,index,array){
      //요소에서 무언가를 할 수 있습니다
    });
    아래는 요소 모두를 얼럿창을 통해 출력해주는 코드입니다
    ["Bilbo","Gandalf","Nazgul"].forEach(alert);
    아래는 인덱스정보까지 더해서 출력해주는 좀더 정교한 코드입니다 
    ["Bilbo","Gandalf","Nazgul"].forEach(function(item, index, array){
      alert(`${item} is at index ${index} in ${array}`);
    });
    참고로 인수로 넘겨준 함수의 반환값은 무시됩니다
    <!-- ["B","G","N"].forEach((item,index,array) => {
      alert(`${item} is at index ${index} in ${array}`);
    }); -->



    ***배열 탐색하기
    배열 내에서 무언가를 찾고 싶을때 쓰는 메서드에 대해 알아봅시다
    indexOf, lastIndexOf와 includes

    arr.indexOf와 arr.lastIndexOf, arr.includes 는 같은 이름을 가진 문자열 메서드와 문법이 동일합니다
    물론 하는 일도 같습니다 연산 대상이 문자열이 아닌 배열의 요소라는 점만 다릅니다
    arr.indexOf(item,from)는 인덱스 from부터 시작해 item(요소)을 찾습니다
    요소를 발견하면 해당 요소의 인덱스를 반환하고, 발견하지 못했으면 -1을 반환합니다
    arr.lastIndexOf(item,from) 는 위 메서드와 동인한 기능을하는데
    검색을 끝에서부터 시작한다는 점만 다릅니다
    arr.includes(item,from) 는 인덱스 from 부터 시작해 item 이 있는지를 검색하는데
    해당 요소를 발견하면 true를 반환합니다
    let arr = [1,0,false];
    alert(arr.indexOf(0)); //1
    alert(arr.indexOf(false));//2
    alert(arr.indexOf(null));//-1
    alert(arr.include(1));//true
    위 메서드들은 요소를 찾을때 완전 항등 연산자 ===을 사용한다는 점에 유의
    보시는바와 같이 false를 검색하면 정확히 false만을 검색하지, 0을 검색하진 않습니다
    요소의 위치를 정확히 알고 싶은게 아니고 요소가 배열 내 존재하는지 여부만 확인하고 싶다면
    arr.includes를 사용하는게 좋습니다
    includes는 NaN도 제대로 처리한다는 점에서 indexOf/lastIndexOf 와 약간의 차이가 있습니다
    const arr = [NaN];
    alert(arr.indexOf(NaN)); // -1 (완전 항등 비교 ===는 NaN엔 동작하지 않으므로 0이 출력되지 않습니다)
    alert(arr.includes(NaN)); // true (NaN의 여부를 확인하였습니다)


    ***find와 findIndex 
    객체로 이루어진 배열이 있다고 가정해봅시다
    특정조건에 부합하는 객체를 배열 내에서 어떻게 찾을 수 있을까요?
    이럴때 arr.find(arr)을 사용할수 있습니다
    문법
    let result = arr.find(function(item, index, array){
      //true가 반환되면 반복이 멈추고 해당요소를 반환합니다
      //조건에 해당하는 요소가 없으면 undefined를 반환합니다
    });
    요소 전체를 대상으로 함수가 순차적으로 호출됩니다
    item - 함수를 호출할 요소
    index - 요소의 인덱스
    array - 배열 자기 자신
    함수가 참을 반환하면 탐색은 중단되고 해당 요소가 반환
    원하는 요소를 찾지 못했으면 undefined가 반환
    id와 name프로퍼티를 가진 사용자 객체로 배열을 예로들어보겠습니다
    배열 내에서 id == 1 조건을 충족하는 사용자 객체를 찾아봅시다
    let users = [
      {id:1, name:"john"},
      {id:2, name:"Pete"},
      {id:3, name:"mary"}
    ]
    let user = users.find(item => item.id == 1);
    <!-- let user = users.find(function(item){
      return item.id == 1;
    }); -->
    console.log(user)
    alert(user.name); //John
    실무에서 객체로 구성된 배열을 다뤄야 할 일이 잦기 때문에 find 메서드 활용법을 알아두면 좋습니다
    그런데 위 예시에서 find 안의 함수가 인자를 하나만 가지고 있다는 점에 주목해주시기 바랍니다
    (item => item.id == 1) 이런 패턴이 가장 많이 사용되는 편입니다
    다른 인자들(index,array)은 잘 사용되지 않습니다
    arr.findIndex는 find와 동일한 일을 하나, 조건에 맞는 요소를 반환하는 대신 
    해당 요소의 인덱스를 반환. 조건에 맞는요소가 없으면 -1이 반환



    ***filter 
    find 메서드는 함수의 반환 값을 tru로 만드는 단 하나의 요소를 찾습니다
    조건을 충족하는 요소가 여러개라면 arr.filter(fn)을 사용하면 됩니다
    filter는 find와 문법이 유사하지만, 조건에 맞는 요소 전체를 담은 배열을 반환한다는 점에서 차이
    let results = arr.filter(function(item, index, array){
      //조건을 충족하는 요소는 results에 순차적으로 더해집니다
      //조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환됩니다
    });

    let users = [
      {id:1, name:"John"},
      {id:2, name:"Pete"},
      {id:3, name:"mary"},
    ];
    //앞쪽 사용자 두명을 반환합니다
    let user = users.filter(function(item){
      return item.id < 3;
    });
    alert(user)
    alert(user.name)




    ***배열을 변현하는 메서드











  </pre>
  <script>
    
  </script>
</body>
</html>