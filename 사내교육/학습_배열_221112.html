<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>

  <pre>
    ***배열
    키를 사용해 식별할 수 있는 값을 담은 컬렉션은 객체라는 구조를 이용해 저장하는데
    객체만으로도 다양한 작업을 할 수 있습니다
    그런데 개발을 진행하다 보면 첫번째 요소, 두번째 요소, 세번째 요소 등과 같이 순서가 있는
    컬렉션이 필요할때 생기곤 합니다
    사용자나 물건, html 요소 목록같이 일목 요연하게 순서를 만들어 정렬하기 위해서 말이죠
    순서가 있는 컬렉션을 다뤄야 할때 객체를 사용하면 순서와 관련된 메서드가 없어 
    그다지 편리하지 않습니다
    객체는 태생이 순서를 고려하지 않고 만들어진 자료구조이기때문에 객체를 이용하면
    새로운 프로퍼티를 기존 프로퍼티 사이에 끼워넣는 것도 불가능
    이럴땐 순서가 있는 컬렉션을 저장할때 쓰는 자료구조인 배열을 사용할 수 있습니다

    ***배열선언
    let arr = new Array();
    let arr = [];

    대부분 두번쨰 방법으로 배열을 선언하는데 이때 대괄호 안에 초기요소를 넣어주는 것도 가능

    let fruit = ['사과', '오렌지', '자두'];

    각 배열 요소엔 0부터 시작하는 숫자(인덱스)가 매겨져 있습니다
    이 숫자들은 배열 내 순서를 나타냅니다
    배열 내 특정 요소를 얻고 싶다면 대괄호 안에 순서를 나타내는 숫자인 인덱스를 넣어주면 됩니다
    let fruit = ['사과', '오렌지', '자두'];
    alert(fruit[0]); //사과
    alert(fruit[1]); //오렌지 
    alert(fruit[2]); //자두
  
    같은 방법으로 요소를 수정할 수 있습니다
    fruit[2] = '배'; 배열이 ['사과','오렌지','배'] 로 바뀜
    
    새로운 요소를 배열에 추가하는 것도 가능
    fruit[3] = '레몬' 배열이 ['사과','오렌지','배','레몬'] 으로 바뀜

    length를 사용하면 배열에 담긴 요소가 몇개인지 알아낼수 있습니다
    let fruit = ['사과', '오렌지', '자두'];
    alert(fruit.length) //3

    alert를 사용해 요소 전체를 출력하는 것도 가능
    let fruit = ['사과', '오렌지', '자두'];
    alert(fruit); //사과,오렌지,자두

    배열 요소의 자료형엔 제약이 없습니다
    //요소에 여러가지 자료형이 섞여 있습니다
    let arr = ['사과', {name:'이보라'}, true, function(){alert('안녕하세요.');}];
    //인덱스가 1인 요소(객체)의 name 프로퍼티를 출력합니다
    alert( arr[1].name ); //이보라
    //인덱스가 3인 요소(함수)를 실행합니다
    arr[3](); //안녕하세요

    
    ***pop,push와 shift,unshift
    큐(Queue)는 배열을 사용해 만들 수 있는 대표적인 자료구조로
    배열과 마찬가지로 순서가 있는 컬렉션을 저장하는데 사용합니다
    큐에서 사용하는 주요연산은 아래와 같습니다
    push - 맨 끝에서 요소를 추가합니다
    shift - 제일 앞 요소를 꺼내 제거한 후 남아있는 요소들을 앞으로 밀어줍니다
    이렇게하면 두번쨰 요소가 첫번쨰 요소가 됩니다

    배열엔 두 연산을 간으케해주는 내장 메서드 push 와 pop이 있습니다
    화면에 순차적으로 띄울 메시지를 비축해 놓을 자료 구조를 만들때 큐를 사용하는 것처럼
    큐는 실무에서 상당히 자주 쓰이는 구조입니다
    배열은 큐 이외에 스택(stack)이라는 불리는 자료구조를 구현할때도 쓰입니다
    스택에서 사용하는 연산은 아래와 같습니다
    push - 요소를 스택 끝에 집어 넣습니다
    pop - 스택 끝 요소를 추출합니다
    스택은 이처럼 한쪽 끝에 요소를 더하거나 뺄 수 있게 해주는 자료구조입니다
    스택은 흔히 카드 한 벌과 비교 됩니다
    쌓여있는 카드 맨 위에 새로운 카드를 더해주거나 빼는 것처럼 스택도 한쪽끝에 요소를 집어넣거나
    추출 할 수 있기 때문입니다
    스택을 사용하면 가장 나중에 집어넣은 요소가 먼저 나옵니다
    이런 특징을 줄여서 후입선출이라고 부릅니다
    반면 큐를 사용하면 먼저 집어 넣은 요소가 먼저 나오기 때문에 큐는 선입선출 자료구조라고합니다
    이렇게 처음이나 끝에 요소를 더하거나 빼주는 연산을 제공하는 자료구조를
    컴퓨터 과학분야에선 데큐라고 부릅니다
    아래는 배열 끝에 문언가를 해주는 메서드입니다
    pop
    배열 끝 요소를 제거하고 제거한 요소를 반환합니다
    let fruit = ['사과', '오렌지', '배'];
    alert(fruit.pop());//배열에서 배를 제거하고 제거된 요소를 얼럿창에 띄웁니다
    alert(fruit)//사과, 오렌지ㅣ
    push
    배열 끝에 요소를 추가합니다
    let fruit = ['사과', '오렌지'];
    fruit.push('배');
    alert(fruit);사과,오렌지,배
    fruit.push(...)를 호출하는 것은 fruit[fruit.length] = ... 하는것과 같은 효과를 보입니다
    아래는 배열 앞에 무언가를 해주는 메서드입니다 
    shift 
    베열 앞 요소를 제거하고 제거한 요소를 반환합니다
    let fruit = ['사과', '오렌지', '자두'];
    alert(fruit.shift()) //사과
    alert(fruit) //오렌지, 자두
    unshift 
    배열앞에 요소를 추가합니다
    let fruit = ['사과', '오렌지', '자두'];
    fruit.unshift('배');
    console.log(fruit); // 배,사과,오렌지,자두
    push와 unshift는 요소 여러개를 한번에 더해줄수도 있습니다
    let fruit = ['사과', '오렌지', '자두'];
    fruit.push('귤','배');
    fruit.unshift('파인애플','레몬');
    console.log(fruit); //파인애플,레몬,사과,오렌지,자두,귤,배

    

    ***배열의 내부 동작 원리
    배열은 특별한 종류의 객체입니다
    배열 arr 의 요소를  arr[0] 처럼 대괄호를 사용해 접근하는 방식은
    객체 문법에서 왔습니다 다만 배열은 키가 숫자라는 점만 다릅니다
    숫자형 키를 사용함으로써 배열은 객체기본기능이외에도 순서가 있는 컬렉션을 제어하게 해주는
    특별한 메서드를 제공합니다
    length라는 프로퍼티도 제공하죠 그렇지만 어쨋든 배열의 본질은 객체입니다
    이렇게 배열은 자바스크립트의 일곱 가지 원시 자료형에 해당하지 않고
    원시 자료형이 아닌 객체형에 속하기 때문에 객체처럼 동작합니다
    예시를 하나 살펴봅시다 배열은 객체와 마찬가지로 참조를 통해 복사됩니다
    let fruit = ['바나나'];
    let arr = fruit; //참조를 복사함(두변수가 같은 객체를 참조)
    alert(fruit === arr); //true
    arr.push('배'); //참조를 이용해 배열을 수정합니다
    alert(fruit); // 바나나,배 -요소가 두개가 되었습니다
    배열을 배열답게 만들어주는 것은 특수 내부 표현방식입니다
    자바스크립트 엔진은 아래쪽 그림에서처럼 배열의 요소를 인접한 메모리 공간에
    차례로 저장해 연산 속도를 높입니다
    이방법 이외에도 배열 관련 연산을 더 빠르게 해주는 최적화 기법은 다양합니다
    그런데 개발자가 배열을 순서가 있는 자료의 컬렉션처럼 다루지 않고
    일반 객체처럼 다루면 이런 기법들이 제대로 동작하지 않습니다
    let fruit = [];// 빈배열을 만듭니다
    fruit[99999] = 5;//배열의 길이보다 훨씬 큰 숫자를 사용해 프로퍼티를 만듭니다
    fruit.age = 25; //임의의 이름을 사용해 프로퍼티를 만듭니다
    배열은 객체이므로 예시처럼 원하는 프로퍼티를 추가해도 문제가 발생하지 않습니다
    그런데 이렇게 코드를 작성하면 자바스크립트 엔진이 배열을 일반 객체처럼 다루게 되어 배열을 다룰때만 적용되는
    최적화 기법이 동작하지 않아 배열 특유의 이점이 사라집니다
    arr.test = 5 // 같이 숫자가 아닌값을 프로퍼티 키로 사용하는 경우
    arr[0]과 arr[1000] 만 추가하고 그 사이에 아무런 요소도 없는 경우
    arr[1000],arr[999] 같이 요소를 역순으로 채우는 경우
    배열은 순서가 있는 자료를 저장하는 용도로 만들어진 특수한 자료구조입니다
    배열 내장 메서드들은 이런용도에 맞게 만들어졌죠
    자바스크립트 엔진은 이런 특성을 고려하여 배열을 신중하게 조정하고
    처리하므로 배열을 사용할 땐 이런 목적에 맞게 사용해주시기바랍니다
    임의의 키를 사용해야한다면 배열보단 일반 객체{}가 적합한 자료구조일 확률이 높습니다



    ***성능
    push 와 pop은 빠르지만 shift와 unshift는 느립니다
    배열 앞에 무언가를 해주는 메서드가 배열 끝에 무언가를 해주는 메서드보다 느린 이유를 실행 흐름을 살펴보면서 알아봅시다
    fruit.shift(); //배열 맨 앞의 요소를 빼줍니다
    shift 메서드를 호출한 것과 동일한 효과를 보려면 인덱스가 0인 요소를 제거하는 것만으론 충분하지 않습니다
    제거 대상이 아닌 나머지 요소들의 인덱스를 수정해줘야 하죠
    .shift연산은 아래 3가지 동작을 모두 수행해야 이뤄집니다
    1.인덱스가 0인 요소를 제거합니다
    2.모든 요소를 왼쪽으로 이동시킵니다 이때 인덱스 1은 0, 2는 1로 변환
    3.length 프로퍼티 값을 갱신합니다
    그런데 배열에 요소가 많으면 요소가 이동하는데 걸리는 시간이 길고 메모리 관련 연산도 많아집니다
    unshift를 실행했을때도 유사한 일이 일어납니다
    요소를 배열 앞에 추가하려면 일단 기존 요소들을 오른쪽으로 이동시켜야하는데 이때 인덱스도 바꿔줘야합니다
    그렇다면 push나 pop은 어떨까요? 이둘은 요소 이동을 수반하지 않습니다
    pop메서드로 요소를 끝에서 제거하려면 마지막 요소를 제거하고
    length프로퍼티의 값을 줄여주기만 하면되죠
    pop메서드를 호출하면 다음과 같은 동작이 일어납니다
    fruit.pop(); //배열 끝 요소 하나를 제거합니다
    pop메서드는 요소를 옮기지 않으므로 각요소는 기존 인덱스를 그대로 유지합니다
    배열 끝에 무언가를 해주는 메서들의 실행속도가 빠른 이유는 바로 여기에 있습니다
    push메서드를 쓸 때도 유사한 동작이 일어나므로 속도가 빠른니다



    ***반복문
    for문은 배열을 순회할때 쓰는 가장 오래된 방법입니다
    순회시엔 인덱스를 사용합니다
    let arr = ["사과", "오렌지" , "배"];
    for(let i = 0; i < arr.length; i++){
      console.log(arr.[i]);
    }
    배열에 적용할 수 있는 또 다른 순회 문법으로 for...of가 있습니다
    let fruit = ['사과','오렌지','자두'];
    for(let i of fruit){
      console.log(fruit);
    }
    for..of를 사용하면 현재 요소의 인덱스는 얻을수 없고 값만 얻을 수 있습니다
    이 정도 기능이면 우너하는것을 충분히 구현할 수 있고 문법도 짧기 때문에
    배열의 요소를 대상으로 반복 작업일땐 for..of를 사용해보시기 바랍니다
    배열은 객체형에 속하므로 for..in을 사용하는 것도 가능합니다
    let arr = ['사과','오렌지','자두'];
    for(let key in arr){
      console.log(arr); //사과, 오렌지, 자두
    }
    그런데 for..in은 다음과 같은 특징을 지니기 때문에
    배열에 for..in을 사용하면 문제가 발생하므로 되도록 다른 반복문을 사용하시기 바랍니다
    1.for..in반복문은 모든 프로퍼티를 대상으로 순회합니다
    키가 숫자가 아닌 프로퍼티도 순회 대상에 포함됩니다
    2.for..in반복문은 배열이 아니라 객체와 함께 사용할때 최적화 되어 있어서 
    배열에 사용하면 객체에 사용하는 것대비 10~100배 정도 느립니다  
    for..in반복문의 속도가 대체로 빠른편이기 때문에 병목지점에서만 문제가 되긴하지만
    for..in반복문을 사용할땐 이런 차이를 알고 적절한 곳에 사용하시길 바랍니다
    그러니 배열엔 되도록 for..in을 쓰지마세요



    ***length 프로퍼티
    배열에 무언가 조작을 가하면 length 프로퍼티가 자동으로 갱신됩니다
    length 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰인덱스에 1을 더한 값입니다
    따라서 배열에 요소가 하나 있고 이요소의 인덱스가 아주 큰 정수라면 배열의 length프로퍼티도 아주 커집니다
    let fruit = [];
    fruit[123] = "사과";
    console.log(fruit.length); //124
    배열을 이렇게 사용하지 않도록 합시다
    length 프로퍼티의 또 다른 독특한 특징 중 하나는 쓰기가 가능하다는 점입니다
    length 의 값을 수동으로 증가시키면 아무일도 일어나지 않습니다
    그런데 값을 감소시키면 배열이 잘립니다
    짧아진 배열은 다시 되돌릴 수 없습니다
    let arr = [1,2,3,4,5];
    arr.length = 2; //요소 2개만 남기고 잘라봅시다
    console.log(arr); //[1,2]
    arr.length = 5; //본래의 길이로 되돌려 봅시다
    console.log(arr[3]) //undefined 삭제된 기존 요쇼들이 복구되지 않습니다
    이런 특징을 이용하면  arr.length = 0;을 사용해 아주 간단하게 배열을 비울 수 있습니다



    ***new Array()
    위에서도 잠시 언급했지만 new Array() 문법을 사용해도 배열을 만들 수 있습니다
    let arr= = new Array('사과','오렌지','기타');
    대괄호[]를 사용하면 더 짧은 문법으로 배열을 만들 수 있기 때문에
    new Array()는 잘 사용되지 않는 편입니다
    new Array()엔 다루기 까다로운 기능도 있어서 더욱더 그렇습니다
    숫자형 인수 하나를 넣어서 new Array를 호출하면 배열이 만들어지는데
    이 배열엔 요소가 없는 반면 길이는 인수와 같아집니다
    예시를 통해 new Array()의 이런 특징이 어떻게 실수를 유발할 수 있는지 알아봅시다
    let arr = new Array(2); //이렇게 하면 배열 [2]가 만들어 질까요?
    console.log(arr[0]); //undefined 가 출력됩니다 요소가 하나도 없는 배열이 만들어졌네요
    console.log(arr.length); //길이는 2입니다
    위예시에서 확인해 본 것처럼 new Array(number)를 이용해 만든 배열의요소는 모두 undefined입니다
    이런 뜻밖의 상황을 마주치지 않기 위해 new Array의 기능을 잘 알지 않는 한 대부분의 개발자가 대괄호를 써서 배열을 만듭니다



    ***다차원배열
    배열 역시 배열의 요소가 될 수 있습니다
    이런 배열을 가리켜 다차원 배열이라 부릅니다
    다차원 배열을 행렬을 저장하는 용도로 쓰입니다
    let matrix = [
      [1,2,3],
      [4,5,6],
      [7,8,9]
    ]
    alert(matrix[1][1]); //5, 중심에 있는 요소



    ***toString
    배열엔 toString 메서드가 구현되어 있어 이를 호출하면 요소를 쉼표로 구분한 문자열이 반환입니다
    let arr = [1,2,3];
    alert(arr); // 1,2,3
    alert(String(arr) === '1,2,3'); //true
    아래 예시를 실행해 봅시다
    alert([]+1); //"1"
    alert([1]+1); // "11"
    alert([1,2]+1]) // "1,21"
    배열엔 symbol.toPrimitive나 valueOf 메서드가 없습니다
    따라서 위 예시에선 문자열로의 형 변환이 일어나 []는 빈 문자열,[1]은 문자열 "1",
    [1,2]는 문자열 "1,2"로 변환됩니다
    이항 덧셈 연산자 "+"는 피연산자 중 하나가 문자열인 경우 나머지 피연산자도 문자열로 변환합니다
    따라서 위예시는 아래 예시와 동일하게 동작합니다
    alert("1");1
    alert("1"+1);11
    alert("1,2"+1);1,21



    ***요약
    //대괄호
    let arr = [item1,item2...];
    //new Array()
    let arr = new Array(item1,item2...);
    new Array(number)를 호출하면 길이가 number인 배열이 만들어지는데 이때 요소는 비어있습니다
    length 프로퍼티는 배열의 길이를 나타내줍니다
    정확히는 숫자형 인덱스중 가장 큰 값에 1을 더한 값입니다
    배열 메서드는 length프로퍼티를 자동으로 조정해줍니다
    length 값을 수동으로 줄이면 배열 끝이 잘립니다
    다음 연산을 사용하면 배열을 데큐처럼 사용할 수 있습니다
    push - 배열끝에 추가
    pop - 배열 끝요소 제거 제거한 요소 반환
    shift - 배열 처음 요소를 제거하고 제거한 요소를 반환 인덱스 수정
    unshift - 배열 처음요소에 더함
    아래 방법을 사용하면 모든 요소를 대상으로 반복 작업을 할 수 있습니다
    for(let i=0; i < arr.length; i++) 가장 빠르고 오랜된 브라우저와 호환
    for(let item of arr) 배열 요소에만 사용되는 모던한 문법
    for(let i in arr) 배열엔 사용하지마세요~



  


  </pre>

  <script>

    //과제
    // //배열은 복사가 될까요?3
    // let fruit = ['사과','배','오렌지'];
    // //배열을 '복사'한 후 , push 메서드를 이용해 새로운 값을 추가합니다
    // let shoppingCart = fruit;
    // shoppingCart.push('바나나'); 
    // //fruit에 어떤 값이 들어있을까요?
    // console.log(fruit.length);//4 //사과, 배, 오렌지, 바나나 


    //배열과 관련된 연산5
    //요소 “Jazz”, "Blues"가 있는 styles 배열을 생성합니다.
    let styles = ["Jazz","Blues"]; //Jazz, Blues
    //"Rock-n-Roll"을 배열 끝에 추가합니다.
    styles.push("Rock-n-Roll");  //Jazz, Blues, Rock-n-Roll
    //배열 정 중앙에 있는 요소를 "Classics"로 바꿉니다. 가운데 요소를 찾는 코드는 요소가 홀수 개인 배열에서도 잘 작동해야 합니다.
    // styles[1] = "Classics"; //땡 조건..
    styles[Math.floor((styles.length -1)/2)] = "Classics";
    //배열의 첫 번째 요소를 꺼내서 출력합니다.
    // console.log(styles[0]); //땡
    console.log(styles.shift());
    //"Rap"과 "Reggae"를 배열의 앞에 추가합니다.
    // styles.unshift("Rap","Reggae");



    //배열 컨텍스트에서 함수 호출하기5
    //아래 코드를 실행하면 어떤 결과가 나올까요? 그리고 그 이유는 무엇일까요?
    // let arr = ['a','b'];
    // arr.push(function(){
    //   alert(this);
    // });
    // arr[2](); //? a,b,function(){alert(this);}
    // arr[2]()를 호출하는 것은 obj가 arr이고 method는 2인 메서는 
    // obj[method]()를 호출하는것과 문법적으로 동일
    // 즉, arr[2]에 있는 함수가 객체 메서드처럼 호출되는 것이죠
    // 따라서 arr[2]는 arr을 참조하는this를 받고 배열을 출력합니다
    //배열은 초기 2개의 값에 함수가 추가되어 총3개의 값을 가집니다



    //입력한 숫자의 합 구하기4
    function sumInput(){
      let arr = [];
      while(true){
        let num = prompt('숫자를 입력하세요','');
        if(num === '' || num === null || !isFinite(num)) break;
        arr.push(+num); //숫자형으로 변환
      }
      let sum = 0;
      for(let i = 0;i<arr.length;i++){
        sum += arr[i];
      }
      return sum;
    }
    //alert(sumInput());
    //+num 으로 입력받은 값을 숫자형으로 변경한 이후엔 빈문자열(정지신호)을 0(유효한숫자)과 구분할수 없기 때문에
    //prompt직후에 num을 숫자로 변환하지 않고 나중에 숫자로 변환~~







    // let fruit = ['사과','오렌지','자두'];
    // console.log(fruit[0]);
    // console.log(fruit[1]);
    // console.log(fruit[2]);


    // let arr = ["사과", "오렌지" , "배"];

    // for(let i = 0; i < arr.length; i++){
    //   console.log(arr[i]);
    // }
    
  </script>
  
</body>
</html>